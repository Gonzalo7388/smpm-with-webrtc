{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar DEFAULT_AUDIO_CONSTRAINTS = {};\nvar DEFAULT_VIDEO_CONSTRAINTS = {\n  facingMode: 'user',\n  frameRate: 30,\n  height: 720,\n  width: 1280\n};\nvar FACING_MODES = ['user', 'environment'];\nvar ASPECT_RATIO = 16 / 9;\nvar STANDARD_OFFER_OPTIONS = {\n  icerestart: 'IceRestart',\n  offertoreceiveaudio: 'OfferToReceiveAudio',\n  offertoreceivevideo: 'OfferToReceiveVideo',\n  voiceactivitydetection: 'VoiceActivityDetection'\n};\nvar SDP_TYPES = ['offer', 'pranswer', 'answer', 'rollback'];\nfunction getDefaultMediaConstraints(mediaType) {\n  switch (mediaType) {\n    case 'audio':\n      return DEFAULT_AUDIO_CONSTRAINTS;\n    case 'video':\n      return DEFAULT_VIDEO_CONSTRAINTS;\n    default:\n      throw new TypeError(\"Invalid media type: \" + mediaType);\n  }\n}\nfunction extractString(constraints, prop) {\n  var value = constraints[prop];\n  var type = typeof value;\n  if (type === 'object') {\n    for (var v of ['exact', 'ideal']) {\n      if (value[v]) {\n        return value[v];\n      }\n    }\n  } else if (type === 'string') {\n    return value;\n  }\n}\nfunction extractNumber(constraints, prop) {\n  var value = constraints[prop];\n  var type = typeof value;\n  if (type === 'number') {\n    return Number.parseInt(value);\n  } else if (type === 'object') {\n    for (var v of ['exact', 'ideal', 'max', 'min']) {\n      if (value[v]) {\n        return Number.parseInt(value[v]);\n      }\n    }\n  }\n}\nfunction normalizeMediaConstraints(constraints, mediaType) {\n  switch (mediaType) {\n    case 'audio':\n      return constraints;\n    case 'video':\n      {\n        var c = {\n          deviceId: extractString(constraints, 'deviceId'),\n          facingMode: extractString(constraints, 'facingMode'),\n          frameRate: extractNumber(constraints, 'frameRate'),\n          height: extractNumber(constraints, 'height'),\n          width: extractNumber(constraints, 'width')\n        };\n        if (!c.deviceId) {\n          delete c.deviceId;\n        }\n        if (!FACING_MODES.includes(c.facingMode)) {\n          c.facingMode = DEFAULT_VIDEO_CONSTRAINTS.facingMode;\n        }\n        if (!c.frameRate) {\n          c.frameRate = DEFAULT_VIDEO_CONSTRAINTS.frameRate;\n        }\n        if (!c.height && !c.width) {\n          c.height = DEFAULT_VIDEO_CONSTRAINTS.height;\n          c.width = DEFAULT_VIDEO_CONSTRAINTS.width;\n        } else if (!c.height && c.width) {\n          c.height = Math.round(c.width / ASPECT_RATIO);\n        } else if (!c.width && c.height) {\n          c.width = Math.round(c.height * ASPECT_RATIO);\n        }\n        return c;\n      }\n    default:\n      throw new TypeError(\"Invalid media type: \" + mediaType);\n  }\n}\nfunction chr4() {\n  return Math.random().toString(16).slice(-4);\n}\nexport function uniqueID() {\n  return \"\" + chr4() + chr4() + \"-\" + chr4() + \"-\" + chr4() + \"-\" + chr4() + \"-\" + chr4() + chr4() + chr4();\n}\nexport function deepClone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\nexport function isSdpTypeValid(type) {\n  return SDP_TYPES.includes(type);\n}\nexport function normalizeOfferOptions() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var newOptions = {};\n  if (!options) {\n    return newOptions;\n  }\n  for (var _ref of Object.entries(options)) {\n    var _ref2 = _slicedToArray(_ref, 2);\n    var key = _ref2[0];\n    var value = _ref2[1];\n    var newKey = STANDARD_OFFER_OPTIONS[key.toLowerCase()];\n    if (newKey) {\n      newOptions[newKey] = String(Boolean(value));\n    }\n  }\n  return newOptions;\n}\nexport function normalizeConstraints(constraints) {\n  var c = deepClone(constraints);\n  for (var mediaType of ['audio', 'video']) {\n    var mediaTypeConstraints = c[mediaType];\n    var typeofMediaTypeConstraints = typeof mediaTypeConstraints;\n    if (typeofMediaTypeConstraints !== 'undefined') {\n      if (typeofMediaTypeConstraints === 'boolean') {\n        if (mediaTypeConstraints) {\n          c[mediaType] = getDefaultMediaConstraints(mediaType);\n        }\n      } else if (typeofMediaTypeConstraints === 'object') {\n        c[mediaType] = normalizeMediaConstraints(mediaTypeConstraints, mediaType);\n      } else {\n        throw new TypeError(\"constraints.\" + mediaType + \" is neither a boolean nor a dictionary\");\n      }\n    }\n  }\n  return c;\n}","map":{"version":3,"names":["DEFAULT_AUDIO_CONSTRAINTS","DEFAULT_VIDEO_CONSTRAINTS","facingMode","frameRate","height","width","FACING_MODES","ASPECT_RATIO","STANDARD_OFFER_OPTIONS","icerestart","offertoreceiveaudio","offertoreceivevideo","voiceactivitydetection","SDP_TYPES","getDefaultMediaConstraints","mediaType","TypeError","extractString","constraints","prop","value","type","v","extractNumber","Number","parseInt","normalizeMediaConstraints","c","deviceId","includes","Math","round","chr4","random","toString","slice","uniqueID","deepClone","obj","JSON","parse","stringify","isSdpTypeValid","normalizeOfferOptions","options","arguments","length","undefined","newOptions","_ref","Object","entries","_ref2","_slicedToArray","key","newKey","toLowerCase","String","Boolean","normalizeConstraints","mediaTypeConstraints","typeofMediaTypeConstraints"],"sources":["/workspaces/smpm-with-webrtc/node_modules/react-native-webrtc/lib/module/RTCUtil.ts"],"sourcesContent":["\nconst DEFAULT_AUDIO_CONSTRAINTS = {};\n\nconst DEFAULT_VIDEO_CONSTRAINTS = {\n    facingMode: 'user',\n    frameRate: 30,\n    height: 720,\n    width: 1280\n};\n\nconst FACING_MODES = [ 'user', 'environment' ];\n\nconst ASPECT_RATIO = 16 / 9;\n\nconst STANDARD_OFFER_OPTIONS = {\n    icerestart: 'IceRestart',\n    offertoreceiveaudio: 'OfferToReceiveAudio',\n    offertoreceivevideo: 'OfferToReceiveVideo',\n    voiceactivitydetection: 'VoiceActivityDetection'\n};\n\nconst SDP_TYPES = [\n    'offer',\n    'pranswer',\n    'answer',\n    'rollback'\n];\n\nfunction getDefaultMediaConstraints(mediaType) {\n    switch (mediaType) {\n        case 'audio':\n            return DEFAULT_AUDIO_CONSTRAINTS;\n        case 'video':\n            return DEFAULT_VIDEO_CONSTRAINTS;\n        default:\n            throw new TypeError(`Invalid media type: ${mediaType}`);\n    }\n}\n\nfunction extractString(constraints, prop) {\n    const value = constraints[prop];\n    const type = typeof value;\n\n    if (type === 'object') {\n        for (const v of [ 'exact', 'ideal' ]) {\n            if (value[v]) {\n                return value[v];\n            }\n        }\n    } else if (type === 'string') {\n        return value;\n    }\n}\n\nfunction extractNumber(constraints, prop) {\n    const value = constraints[prop];\n    const type = typeof value;\n\n    if (type === 'number') {\n        return Number.parseInt(value);\n    } else if (type === 'object') {\n        for (const v of [ 'exact', 'ideal', 'max', 'min' ]) {\n            if (value[v]) {\n                return Number.parseInt(value[v]);\n            }\n        }\n    }\n}\n\nfunction normalizeMediaConstraints(constraints, mediaType) {\n    switch (mediaType) {\n        case 'audio':\n            return constraints;\n\n        case 'video': {\n            const c = {\n                deviceId: extractString(constraints, 'deviceId'),\n                facingMode: extractString(constraints, 'facingMode'),\n                frameRate: extractNumber(constraints, 'frameRate'),\n                height: extractNumber(constraints, 'height'),\n                width: extractNumber(constraints, 'width')\n            };\n\n            if (!c.deviceId) {\n                delete c.deviceId;\n            }\n\n            if (!FACING_MODES.includes(c.facingMode)) {\n                c.facingMode = DEFAULT_VIDEO_CONSTRAINTS.facingMode;\n            }\n\n            if (!c.frameRate) {\n                c.frameRate = DEFAULT_VIDEO_CONSTRAINTS.frameRate;\n            }\n\n            if (!c.height && !c.width) {\n                c.height = DEFAULT_VIDEO_CONSTRAINTS.height;\n                c.width = DEFAULT_VIDEO_CONSTRAINTS.width;\n            } else if (!c.height && c.width) {\n                c.height = Math.round(c.width / ASPECT_RATIO);\n            } else if (!c.width && c.height) {\n                c.width = Math.round(c.height * ASPECT_RATIO);\n            }\n\n            return c;\n        }\n\n        default:\n            throw new TypeError(`Invalid media type: ${mediaType}`);\n    }\n}\n\n/**\n * Utility for creating short random strings from float point values.\n * We take 4 characters from the end after converting to a string.\n * Conversion to string gives us some letters as we don't want just numbers.\n * Should be suitable to pass for enough randomness.\n *\n * @return {String} 4 random characters\n */\nfunction chr4() {\n    return Math.random().toString(16).slice(-4);\n}\n\n/**\n * Put together a random string in UUIDv4 format {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\n *\n * @return {String} uuidv4\n */\nexport function uniqueID(): string {\n    return `${chr4()}${chr4()}-${chr4()}-${chr4()}-${chr4()}-${chr4()}${chr4()}${chr4()}`;\n}\n\n/**\n * Utility for deep cloning an object. Object.assign() only does a shallow copy.\n *\n * @param {Object} obj - object to be cloned\n * @return {Object} cloned obj\n */\nexport function deepClone<T>(obj: T): T {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Checks whether an SDP type is valid or not.\n *\n * @param type SDP type to check.\n * @returns Whether the SDP type is valid or not.\n */\nexport function isSdpTypeValid(type: string): boolean {\n    return SDP_TYPES.includes(type);\n}\n\n/**\n * Normalize options passed to createOffer().\n *\n * @param options - user supplied options\n * @return Normalized options\n */\nexport function normalizeOfferOptions(options: object = {}): object {\n    const newOptions = {};\n\n    if (!options) {\n        return newOptions;\n    }\n\n    // Convert standard options into WebRTC internal constant names.\n    // See: https://github.com/jitsi/webrtc/blob/0cd6ce4de669bed94ba47b88cb71b9be0341bb81/sdk/media_constraints.cc#L113\n    for (const [ key, value ] of Object.entries(options)) {\n        const newKey = STANDARD_OFFER_OPTIONS[key.toLowerCase()];\n\n        if (newKey) {\n            newOptions[newKey] = String(Boolean(value));\n        }\n    }\n\n    return newOptions;\n}\n\n/**\n * Normalize the given constraints in something we can work with.\n */\nexport function normalizeConstraints(constraints) {\n    const c = deepClone(constraints);\n\n    for (const mediaType of [ 'audio', 'video' ]) {\n        const mediaTypeConstraints = c[mediaType];\n        const typeofMediaTypeConstraints = typeof mediaTypeConstraints;\n\n        if (typeofMediaTypeConstraints !== 'undefined') {\n            if (typeofMediaTypeConstraints === 'boolean') {\n                if (mediaTypeConstraints) {\n                    c[mediaType] = getDefaultMediaConstraints(mediaType);\n                }\n            } else if (typeofMediaTypeConstraints === 'object') {\n                c[mediaType] = normalizeMediaConstraints(mediaTypeConstraints, mediaType);\n            } else {\n                throw new TypeError(`constraints.${mediaType} is neither a boolean nor a dictionary`);\n            }\n        }\n    }\n\n    return c;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}