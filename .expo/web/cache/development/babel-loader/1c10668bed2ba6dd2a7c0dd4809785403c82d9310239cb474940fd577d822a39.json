{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty2 from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty2(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { defineCustomEventTarget } from 'event-target-shim';\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport { addListener, removeListener } from \"./EventEmitter\";\nimport Logger from \"./Logger\";\nimport MediaStream from \"./MediaStream\";\nimport MediaStreamTrack from \"./MediaStreamTrack\";\nimport MediaStreamTrackEvent from \"./MediaStreamTrackEvent\";\nimport RTCDataChannel from \"./RTCDataChannel\";\nimport RTCDataChannelEvent from \"./RTCDataChannelEvent\";\nimport RTCEvent from \"./RTCEvent\";\nimport RTCIceCandidate from \"./RTCIceCandidate\";\nimport RTCIceCandidateEvent from \"./RTCIceCandidateEvent\";\nimport RTCRtpReceiveParameters from \"./RTCRtpReceiveParameters\";\nimport RTCRtpReceiver from \"./RTCRtpReceiver\";\nimport RTCRtpSendParameters from \"./RTCRtpSendParameters\";\nimport RTCRtpSender from \"./RTCRtpSender\";\nimport RTCRtpTransceiver from \"./RTCRtpTransceiver\";\nimport RTCSessionDescription from \"./RTCSessionDescription\";\nimport RTCTrackEvent from \"./RTCTrackEvent\";\nimport * as RTCUtil from \"./RTCUtil\";\nvar log = new Logger('pc');\nvar WebRTCModule = NativeModules.WebRTCModule;\nvar PEER_CONNECTION_EVENTS = ['connectionstatechange', 'icecandidate', 'icecandidateerror', 'iceconnectionstatechange', 'icegatheringstatechange', 'negotiationneeded', 'signalingstatechange', 'datachannel', 'track', 'error'];\nvar nextPeerConnectionId = 0;\nvar RTCPeerConnection = function (_defineCustomEventTar) {\n  function RTCPeerConnection(configuration) {\n    var _this;\n    _classCallCheck(this, RTCPeerConnection);\n    _this = _callSuper(this, RTCPeerConnection);\n    _defineProperty(_this, \"localDescription\", null);\n    _defineProperty(_this, \"remoteDescription\", null);\n    _defineProperty(_this, \"signalingState\", 'stable');\n    _defineProperty(_this, \"iceGatheringState\", 'new');\n    _defineProperty(_this, \"connectionState\", 'new');\n    _defineProperty(_this, \"iceConnectionState\", 'new');\n    _defineProperty(_this, \"_pcId\", void 0);\n    _defineProperty(_this, \"_transceivers\", void 0);\n    _defineProperty(_this, \"_remoteStreams\", void 0);\n    _defineProperty(_this, \"_pendingTrackEvents\", void 0);\n    _this._pcId = nextPeerConnectionId++;\n    WebRTCModule.peerConnectionInit(configuration, _this._pcId);\n    _this._transceivers = [];\n    _this._remoteStreams = new Map();\n    _this._pendingTrackEvents = [];\n    _this._registerEvents();\n    log.debug(_this._pcId + \" ctor\");\n    return _this;\n  }\n  _inherits(RTCPeerConnection, _defineCustomEventTar);\n  return _createClass(RTCPeerConnection, [{\n    key: \"createOffer\",\n    value: function () {\n      var _createOffer = _asyncToGenerator(function* (options) {\n        log.debug(this._pcId + \" createOffer\");\n        var _yield$WebRTCModule$p = yield WebRTCModule.peerConnectionCreateOffer(this._pcId, RTCUtil.normalizeOfferOptions(options)),\n          sdpInfo = _yield$WebRTCModule$p.sdpInfo,\n          transceiversInfo = _yield$WebRTCModule$p.transceiversInfo;\n        log.debug(this._pcId + \" createOffer OK\");\n        this._updateTransceivers(transceiversInfo);\n        return sdpInfo;\n      });\n      function createOffer(_x) {\n        return _createOffer.apply(this, arguments);\n      }\n      return createOffer;\n    }()\n  }, {\n    key: \"createAnswer\",\n    value: function () {\n      var _createAnswer = _asyncToGenerator(function* () {\n        log.debug(this._pcId + \" createAnswer\");\n        var _yield$WebRTCModule$p2 = yield WebRTCModule.peerConnectionCreateAnswer(this._pcId, {}),\n          sdpInfo = _yield$WebRTCModule$p2.sdpInfo,\n          transceiversInfo = _yield$WebRTCModule$p2.transceiversInfo;\n        this._updateTransceivers(transceiversInfo);\n        return sdpInfo;\n      });\n      function createAnswer() {\n        return _createAnswer.apply(this, arguments);\n      }\n      return createAnswer;\n    }()\n  }, {\n    key: \"setConfiguration\",\n    value: function setConfiguration(configuration) {\n      WebRTCModule.peerConnectionSetConfiguration(configuration, this._pcId);\n    }\n  }, {\n    key: \"setLocalDescription\",\n    value: function () {\n      var _setLocalDescription = _asyncToGenerator(function* (sessionDescription) {\n        var _desc;\n        log.debug(this._pcId + \" setLocalDescription\");\n        var desc;\n        if (sessionDescription) {\n          var _sessionDescription$s;\n          desc = {\n            type: sessionDescription.type,\n            sdp: (_sessionDescription$s = sessionDescription.sdp) !== null && _sessionDescription$s !== void 0 ? _sessionDescription$s : ''\n          };\n          if (!RTCUtil.isSdpTypeValid(desc.type)) {\n            throw new Error(\"Invalid session description: invalid type: \" + desc.type);\n          }\n        } else {\n          desc = null;\n        }\n        var _yield$WebRTCModule$p3 = yield WebRTCModule.peerConnectionSetLocalDescription(this._pcId, desc),\n          sdpInfo = _yield$WebRTCModule$p3.sdpInfo,\n          transceiversInfo = _yield$WebRTCModule$p3.transceiversInfo;\n        if (sdpInfo.type && sdpInfo.sdp) {\n          this.localDescription = new RTCSessionDescription(sdpInfo);\n        } else {\n          this.localDescription = null;\n        }\n        this._updateTransceivers(transceiversInfo, ((_desc = desc) === null || _desc === void 0 ? void 0 : _desc.type) === 'answer');\n        log.debug(this._pcId + \" setLocalDescription OK\");\n      });\n      function setLocalDescription(_x2) {\n        return _setLocalDescription.apply(this, arguments);\n      }\n      return setLocalDescription;\n    }()\n  }, {\n    key: \"setRemoteDescription\",\n    value: function () {\n      var _setRemoteDescription = _asyncToGenerator(function* (sessionDescription) {\n        var _this2 = this;\n        var _sessionDescription$s2, _desc$type;\n        log.debug(this._pcId + \" setRemoteDescription\");\n        if (!sessionDescription) {\n          return Promise.reject(new Error('No session description provided'));\n        }\n        var desc = {\n          type: sessionDescription.type,\n          sdp: (_sessionDescription$s2 = sessionDescription.sdp) !== null && _sessionDescription$s2 !== void 0 ? _sessionDescription$s2 : ''\n        };\n        if (!RTCUtil.isSdpTypeValid((_desc$type = desc.type) !== null && _desc$type !== void 0 ? _desc$type : '')) {\n          throw new Error(\"Invalid session description: invalid type: \" + desc.type);\n        }\n        var _yield$WebRTCModule$p4 = yield WebRTCModule.peerConnectionSetRemoteDescription(this._pcId, desc),\n          sdpInfo = _yield$WebRTCModule$p4.sdpInfo,\n          newTransceivers = _yield$WebRTCModule$p4.newTransceivers,\n          transceiversInfo = _yield$WebRTCModule$p4.transceiversInfo;\n        if (sdpInfo.type && sdpInfo.sdp) {\n          this.remoteDescription = new RTCSessionDescription(sdpInfo);\n        } else {\n          this.remoteDescription = null;\n        }\n        newTransceivers === null || newTransceivers === void 0 ? void 0 : newTransceivers.forEach(function (t) {\n          var transceiverOrder = t.transceiverOrder,\n            transceiver = t.transceiver;\n          var newSender = new RTCRtpSender(_objectSpread(_objectSpread({}, transceiver.sender), {}, {\n            track: null\n          }));\n          var remoteTrack = transceiver.receiver.track ? new MediaStreamTrack(transceiver.receiver.track) : null;\n          var newReceiver = new RTCRtpReceiver(_objectSpread(_objectSpread({}, transceiver.receiver), {}, {\n            track: remoteTrack\n          }));\n          var newTransceiver = new RTCRtpTransceiver(_objectSpread(_objectSpread({}, transceiver), {}, {\n            sender: newSender,\n            receiver: newReceiver\n          }));\n          _this2._insertTransceiverSorted(transceiverOrder, newTransceiver);\n        });\n        this._updateTransceivers(transceiversInfo, desc.type === 'answer');\n        var pendingTrackEvents = this._pendingTrackEvents;\n        this._pendingTrackEvents = [];\n        var _loop = function* _loop(ev) {\n          var _this2$getTransceiver = _this2.getTransceivers().filter(function (t) {\n              return t.receiver.id === ev.receiver.id;\n            }),\n            _this2$getTransceiver2 = _slicedToArray(_this2$getTransceiver, 1),\n            transceiver = _this2$getTransceiver2[0];\n          var track = transceiver.receiver.track;\n          transceiver._mid = ev.transceiver.mid;\n          transceiver._currentDirection = ev.transceiver.currentDirection;\n          transceiver._direction = ev.transceiver.direction;\n          var streams = ev.streams.map(function (streamInfo) {\n            if (!_this2._remoteStreams.has(streamInfo.streamId)) {\n              var _stream = new MediaStream({\n                streamId: streamInfo.streamId,\n                streamReactTag: streamInfo.streamReactTag,\n                tracks: []\n              });\n              _this2._remoteStreams.set(streamInfo.streamId, _stream);\n            }\n            var stream = _this2._remoteStreams.get(streamInfo.streamId);\n            if (!(stream !== null && stream !== void 0 && stream._tracks.includes(track))) {\n              stream === null || stream === void 0 ? void 0 : stream._tracks.push(track);\n            }\n            return stream;\n          });\n          var eventData = {\n            streams: streams,\n            transceiver: transceiver,\n            track: track,\n            receiver: transceiver.receiver\n          };\n          _this2.dispatchEvent(new RTCTrackEvent('track', eventData));\n          streams.forEach(function (stream) {\n            stream.dispatchEvent(new MediaStreamTrackEvent('addtrack', {\n              track: track\n            }));\n          });\n          track._setMutedInternal(false);\n        };\n        for (var ev of pendingTrackEvents) {\n          yield* _loop(ev);\n        }\n        log.debug(this._pcId + \" setRemoteDescription OK\");\n      });\n      function setRemoteDescription(_x3) {\n        return _setRemoteDescription.apply(this, arguments);\n      }\n      return setRemoteDescription;\n    }()\n  }, {\n    key: \"addIceCandidate\",\n    value: function () {\n      var _addIceCandidate = _asyncToGenerator(function* (candidate) {\n        log.debug(this._pcId + \" addIceCandidate\");\n        if (!candidate || !candidate.candidate) {\n          return;\n        }\n        if (candidate.sdpMLineIndex === null || candidate.sdpMLineIndex === undefined || candidate.sdpMid === null || candidate.sdpMid === undefined) {\n          throw new TypeError('`sdpMLineIndex` and `sdpMid` must not null or undefined');\n        }\n        var newSdp = yield WebRTCModule.peerConnectionAddICECandidate(this._pcId, candidate.toJSON ? candidate.toJSON() : candidate);\n        this.remoteDescription = new RTCSessionDescription(newSdp);\n      });\n      function addIceCandidate(_x4) {\n        return _addIceCandidate.apply(this, arguments);\n      }\n      return addIceCandidate;\n    }()\n  }, {\n    key: \"addTrack\",\n    value: function addTrack(track) {\n      log.debug(this._pcId + \" addTrack\");\n      if (this.connectionState === 'closed') {\n        throw new Error('Peer Connection is closed');\n      }\n      if (this._trackExists(track)) {\n        throw new Error('Track already exists in a sender');\n      }\n      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        streams[_key - 1] = arguments[_key];\n      }\n      var streamIds = streams.map(function (s) {\n        return s.id;\n      });\n      var result = WebRTCModule.peerConnectionAddTrack(this._pcId, track.id, {\n        streamIds: streamIds\n      });\n      if (result === null) {\n        throw new Error('Could not add sender');\n      }\n      var transceiverOrder = result.transceiverOrder,\n        transceiver = result.transceiver,\n        sender = result.sender;\n      var _this$getSenders$filt = this.getSenders().filter(function (s) {\n          return s.id === sender.id;\n        }),\n        _this$getSenders$filt2 = _slicedToArray(_this$getSenders$filt, 1),\n        existingSender = _this$getSenders$filt2[0];\n      if (existingSender) {\n        existingSender._track = track;\n        var _this$getTransceivers = this.getTransceivers().filter(function (t) {\n            return t.sender.id === existingSender.id;\n          }),\n          _this$getTransceivers2 = _slicedToArray(_this$getTransceivers, 1),\n          existingTransceiver = _this$getTransceivers2[0];\n        existingTransceiver._direction = transceiver.direction;\n        existingTransceiver._currentDirection = transceiver.currentDirection;\n        return existingSender;\n      }\n      var newSender = new RTCRtpSender(_objectSpread(_objectSpread({}, transceiver.sender), {}, {\n        track: track\n      }));\n      var remoteTrack = transceiver.receiver.track ? new MediaStreamTrack(transceiver.receiver.track) : null;\n      var newReceiver = new RTCRtpReceiver(_objectSpread(_objectSpread({}, transceiver.receiver), {}, {\n        track: remoteTrack\n      }));\n      var newTransceiver = new RTCRtpTransceiver(_objectSpread(_objectSpread({}, transceiver), {}, {\n        sender: newSender,\n        receiver: newReceiver\n      }));\n      this._insertTransceiverSorted(transceiverOrder, newTransceiver);\n      return newSender;\n    }\n  }, {\n    key: \"addTransceiver\",\n    value: function addTransceiver(source, init) {\n      log.debug(this._pcId + \" addTransceiver\");\n      var src = {};\n      if (source === 'audio') {\n        src = {\n          type: 'audio'\n        };\n      } else if (source === 'video') {\n        src = {\n          type: 'video'\n        };\n      } else {\n        src = {\n          trackId: source.id\n        };\n      }\n      if (init && init.streams) {\n        init.streamIds = init.streams.map(function (stream) {\n          return stream.id;\n        });\n      }\n      var result = WebRTCModule.peerConnectionAddTransceiver(this._pcId, _objectSpread(_objectSpread({}, src), {}, {\n        init: _objectSpread({}, init)\n      }));\n      if (result === null) {\n        throw new Error('Transceiver could not be added');\n      }\n      var t = result.transceiver;\n      var track = null;\n      if (typeof source === 'string') {\n        if (t.sender.track) {\n          track = new MediaStreamTrack(t.sender.track);\n        }\n      } else {\n        track = source;\n      }\n      var sender = new RTCRtpSender(_objectSpread(_objectSpread({}, t.sender), {}, {\n        track: track\n      }));\n      var remoteTrack = t.receiver.track ? new MediaStreamTrack(t.receiver.track) : null;\n      var receiver = new RTCRtpReceiver(_objectSpread(_objectSpread({}, t.receiver), {}, {\n        track: remoteTrack\n      }));\n      var transceiver = new RTCRtpTransceiver(_objectSpread(_objectSpread({}, result.transceiver), {}, {\n        sender: sender,\n        receiver: receiver\n      }));\n      this._insertTransceiverSorted(result.transceiverOrder, transceiver);\n      return transceiver;\n    }\n  }, {\n    key: \"removeTrack\",\n    value: function removeTrack(sender) {\n      log.debug(this._pcId + \" removeTrack\");\n      if (this._pcId !== sender._peerConnectionId) {\n        throw new Error('Sender does not belong to this peer connection');\n      }\n      if (this.connectionState === 'closed') {\n        throw new Error('Peer Connection is closed');\n      }\n      var existingSender = this.getSenders().find(function (s) {\n        return s === sender;\n      });\n      if (!existingSender) {\n        throw new Error('Sender does not exist');\n      }\n      if (existingSender.track === null) {\n        return;\n      }\n      WebRTCModule.peerConnectionRemoveTrack(this._pcId, sender.id);\n      existingSender._track = null;\n      var _this$getTransceivers3 = this.getTransceivers().filter(function (t) {\n          return t.sender.id === existingSender.id;\n        }),\n        _this$getTransceivers4 = _slicedToArray(_this$getTransceivers3, 1),\n        existingTransceiver = _this$getTransceivers4[0];\n      existingTransceiver._direction = existingTransceiver.direction === 'sendrecv' ? 'recvonly' : 'inactive';\n    }\n  }, {\n    key: \"getStats\",\n    value: function () {\n      var _getStats = _asyncToGenerator(function* (selector) {\n        log.debug(this._pcId + \" getStats\");\n        if (!selector) {\n          var data = yield WebRTCModule.peerConnectionGetStats(this._pcId);\n          return new Map(JSON.parse(data));\n        } else {\n          var senders = this.getSenders().filter(function (s) {\n            return s.track === selector;\n          });\n          var receivers = this.getReceivers().filter(function (r) {\n            return r.track === selector;\n          });\n          var matches = senders.length + receivers.length;\n          if (matches === 0) {\n            throw new Error('Invalid selector: could not find matching sender / receiver');\n          } else if (matches > 1) {\n            throw new Error('Invalid selector: multiple matching senders / receivers');\n          } else {\n            var sr = senders[0] || receivers[0];\n            return sr.getStats();\n          }\n        }\n      });\n      function getStats(_x5) {\n        return _getStats.apply(this, arguments);\n      }\n      return getStats;\n    }()\n  }, {\n    key: \"getTransceivers\",\n    value: function getTransceivers() {\n      return this._transceivers.map(function (e) {\n        return e.transceiver;\n      });\n    }\n  }, {\n    key: \"getSenders\",\n    value: function getSenders() {\n      return this._transceivers.map(function (e) {\n        return !e.transceiver.stopped && e.transceiver.sender;\n      }).filter(Boolean);\n    }\n  }, {\n    key: \"getReceivers\",\n    value: function getReceivers() {\n      return this._transceivers.map(function (e) {\n        return !e.transceiver.stopped && e.transceiver.receiver;\n      }).filter(Boolean);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      log.debug(this._pcId + \" close\");\n      if (this.connectionState === 'closed') {\n        return;\n      }\n      WebRTCModule.peerConnectionClose(this._pcId);\n      this._transceivers.forEach(function (_ref) {\n        var transceiver = _ref.transceiver;\n        transceiver._setStopped();\n      });\n    }\n  }, {\n    key: \"restartIce\",\n    value: function restartIce() {\n      WebRTCModule.peerConnectionRestartIce(this._pcId);\n    }\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      var _this3 = this;\n      addListener(this, 'peerConnectionOnRenegotiationNeeded', function (ev) {\n        if (ev.pcId !== _this3._pcId) {\n          return;\n        }\n        _this3.dispatchEvent(new RTCEvent('negotiationneeded'));\n      });\n      addListener(this, 'peerConnectionIceConnectionChanged', function (ev) {\n        if (ev.pcId !== _this3._pcId) {\n          return;\n        }\n        _this3.iceConnectionState = ev.iceConnectionState;\n        _this3.dispatchEvent(new RTCEvent('iceconnectionstatechange'));\n      });\n      addListener(this, 'peerConnectionStateChanged', function (ev) {\n        if (ev.pcId !== _this3._pcId) {\n          return;\n        }\n        _this3.connectionState = ev.connectionState;\n        _this3.dispatchEvent(new RTCEvent('connectionstatechange'));\n        if (ev.connectionState === 'closed') {\n          removeListener(_this3);\n          WebRTCModule.peerConnectionDispose(_this3._pcId);\n        }\n      });\n      addListener(this, 'peerConnectionSignalingStateChanged', function (ev) {\n        if (ev.pcId !== _this3._pcId) {\n          return;\n        }\n        _this3.signalingState = ev.signalingState;\n        _this3.dispatchEvent(new RTCEvent('signalingstatechange'));\n      });\n      addListener(this, 'peerConnectionOnTrack', function (ev) {\n        if (ev.pcId !== _this3._pcId) {\n          return;\n        }\n        log.debug(_this3._pcId + \" ontrack\");\n        _this3._pendingTrackEvents.push(ev);\n      });\n      addListener(this, 'peerConnectionOnRemoveTrack', function (ev) {\n        if (ev.pcId !== _this3._pcId) {\n          return;\n        }\n        log.debug(_this3._pcId + \" onremovetrack \" + ev.receiverId);\n        var receiver = _this3.getReceivers().find(function (r) {\n          return r.id === ev.receiverId;\n        });\n        var track = receiver === null || receiver === void 0 ? void 0 : receiver.track;\n        if (receiver && track) {\n          for (var stream of _this3._remoteStreams.values()) {\n            if (stream._tracks.includes(track)) {\n              var trackIdx = stream._tracks.indexOf(track);\n              log.debug(_this3._pcId + \" removetrack \" + track.id);\n              stream._tracks.splice(trackIdx, 1);\n              stream.dispatchEvent(new MediaStreamTrackEvent('removetrack', {\n                track: track\n              }));\n              track._setMutedInternal(true);\n            }\n          }\n        }\n      });\n      addListener(this, 'peerConnectionGotICECandidate', function (ev) {\n        if (ev.pcId !== _this3._pcId) {\n          return;\n        }\n        var sdpInfo = ev.sdp;\n        if (sdpInfo.type && sdpInfo.sdp) {\n          _this3.localDescription = new RTCSessionDescription(sdpInfo);\n        } else {\n          _this3.localDescription = null;\n        }\n        var candidate = new RTCIceCandidate(ev.candidate);\n        _this3.dispatchEvent(new RTCIceCandidateEvent('icecandidate', {\n          candidate: candidate\n        }));\n      });\n      addListener(this, 'peerConnectionIceGatheringChanged', function (ev) {\n        if (ev.pcId !== _this3._pcId) {\n          return;\n        }\n        _this3.iceGatheringState = ev.iceGatheringState;\n        if (_this3.iceGatheringState === 'complete') {\n          var sdpInfo = ev.sdp;\n          if (sdpInfo.type && sdpInfo.sdp) {\n            _this3.localDescription = new RTCSessionDescription(sdpInfo);\n          } else {\n            _this3.localDescription = null;\n          }\n          _this3.dispatchEvent(new RTCIceCandidateEvent('icecandidate', {\n            candidate: null\n          }));\n        }\n        _this3.dispatchEvent(new RTCEvent('icegatheringstatechange'));\n      });\n      addListener(this, 'peerConnectionDidOpenDataChannel', function (ev) {\n        if (ev.pcId !== _this3._pcId) {\n          return;\n        }\n        var channel = new RTCDataChannel(ev.dataChannel);\n        _this3.dispatchEvent(new RTCDataChannelEvent('datachannel', {\n          channel: channel\n        }));\n      });\n      addListener(this, 'mediaStreamTrackMuteChanged', function (ev) {\n        if (ev.pcId !== _this3._pcId) {\n          return;\n        }\n        var _this3$getReceivers$m = _this3.getReceivers().map(function (r) {\n            return r.track;\n          }).filter(function (t) {\n            return (t === null || t === void 0 ? void 0 : t.id) === ev.trackId;\n          }),\n          _this3$getReceivers$m2 = _slicedToArray(_this3$getReceivers$m, 1),\n          track = _this3$getReceivers$m2[0];\n        if (track) {\n          track._setMutedInternal(ev.muted);\n        }\n      });\n    }\n  }, {\n    key: \"createDataChannel\",\n    value: function createDataChannel(label, dataChannelDict) {\n      if (dataChannelDict && 'id' in dataChannelDict) {\n        var id = dataChannelDict.id;\n        if (typeof id !== 'number') {\n          throw new TypeError('DataChannel id must be a number: ' + id);\n        }\n      }\n      var channelInfo = WebRTCModule.createDataChannel(this._pcId, label, dataChannelDict);\n      if (channelInfo === null) {\n        throw new TypeError('Failed to create new DataChannel');\n      }\n      return new RTCDataChannel(channelInfo);\n    }\n  }, {\n    key: \"_trackExists\",\n    value: function _trackExists(track) {\n      var _this$getSenders$filt3 = this.getSenders().filter(function (sender) {\n          var _sender$track;\n          return ((_sender$track = sender.track) === null || _sender$track === void 0 ? void 0 : _sender$track.id) === track.id;\n        }),\n        _this$getSenders$filt4 = _slicedToArray(_this$getSenders$filt3, 1),\n        sender = _this$getSenders$filt4[0];\n      return sender ? true : false;\n    }\n  }, {\n    key: \"_updateTransceivers\",\n    value: function _updateTransceivers(transceiverUpdates) {\n      var _this4 = this;\n      var removeStopped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var _loop2 = function _loop2(update) {\n        var _this4$getTransceiver = _this4.getTransceivers().filter(function (t) {\n            return t.sender.id === update.transceiverId;\n          }),\n          _this4$getTransceiver2 = _slicedToArray(_this4$getTransceiver, 1),\n          transceiver = _this4$getTransceiver2[0];\n        if (!transceiver) {\n          return 1;\n        }\n        transceiver._currentDirection = update.currentDirection;\n        transceiver._mid = update.mid;\n        transceiver._stopped = Boolean(update.isStopped);\n        transceiver._sender._rtpParameters = new RTCRtpSendParameters(update.senderRtpParameters);\n        transceiver._receiver._rtpParameters = new RTCRtpReceiveParameters(update.receiverRtpParameters);\n      };\n      for (var update of transceiverUpdates) {\n        if (_loop2(update)) continue;\n      }\n      if (removeStopped) {\n        var stopped = this.getTransceivers().filter(function (t) {\n          return t.stopped;\n        });\n        var newTransceivers = this._transceivers.filter(function (t) {\n          return !stopped.includes(t.transceiver);\n        });\n        this._transceivers = newTransceivers;\n      }\n    }\n  }, {\n    key: \"_insertTransceiverSorted\",\n    value: function _insertTransceiverSorted(order, transceiver) {\n      this._transceivers.push({\n        order: order,\n        transceiver: transceiver\n      });\n      this._transceivers.sort(function (a, b) {\n        return a.order - b.order;\n      });\n    }\n  }]);\n}(defineCustomEventTarget.apply(void 0, PEER_CONNECTION_EVENTS));\nexport { RTCPeerConnection as default };","map":{"version":3,"names":["defineCustomEventTarget","NativeModules","addListener","removeListener","Logger","MediaStream","MediaStreamTrack","MediaStreamTrackEvent","RTCDataChannel","RTCDataChannelEvent","RTCEvent","RTCIceCandidate","RTCIceCandidateEvent","RTCRtpReceiveParameters","RTCRtpReceiver","RTCRtpSendParameters","RTCRtpSender","RTCRtpTransceiver","RTCSessionDescription","RTCTrackEvent","RTCUtil","log","WebRTCModule","PEER_CONNECTION_EVENTS","nextPeerConnectionId","RTCPeerConnection","_defineCustomEventTar","configuration","_this","_classCallCheck","_callSuper","_defineProperty","_pcId","peerConnectionInit","_transceivers","_remoteStreams","Map","_pendingTrackEvents","_registerEvents","debug","_inherits","_createClass","key","value","_createOffer","_asyncToGenerator","options","_yield$WebRTCModule$p","peerConnectionCreateOffer","normalizeOfferOptions","sdpInfo","transceiversInfo","_updateTransceivers","createOffer","_x","apply","arguments","_createAnswer","_yield$WebRTCModule$p2","peerConnectionCreateAnswer","createAnswer","setConfiguration","peerConnectionSetConfiguration","_setLocalDescription","sessionDescription","_desc","desc","_sessionDescription$s","type","sdp","isSdpTypeValid","Error","_yield$WebRTCModule$p3","peerConnectionSetLocalDescription","localDescription","setLocalDescription","_x2","_setRemoteDescription","_this2","_sessionDescription$s2","_desc$type","Promise","reject","_yield$WebRTCModule$p4","peerConnectionSetRemoteDescription","newTransceivers","remoteDescription","forEach","t","transceiverOrder","transceiver","newSender","_objectSpread","sender","track","remoteTrack","receiver","newReceiver","newTransceiver","_insertTransceiverSorted","pendingTrackEvents","_loop","ev","_this2$getTransceiver","getTransceivers","filter","id","_this2$getTransceiver2","_slicedToArray","_mid","mid","_currentDirection","currentDirection","_direction","direction","streams","map","streamInfo","has","streamId","stream","streamReactTag","tracks","set","get","_tracks","includes","push","eventData","dispatchEvent","_setMutedInternal","setRemoteDescription","_x3","_addIceCandidate","candidate","sdpMLineIndex","undefined","sdpMid","TypeError","newSdp","peerConnectionAddICECandidate","toJSON","addIceCandidate","_x4","addTrack","connectionState","_trackExists","_len","length","Array","_key","streamIds","s","result","peerConnectionAddTrack","_this$getSenders$filt","getSenders","_this$getSenders$filt2","existingSender","_track","_this$getTransceivers","_this$getTransceivers2","existingTransceiver","addTransceiver","source","init","src","trackId","peerConnectionAddTransceiver","removeTrack","_peerConnectionId","find","peerConnectionRemoveTrack","_this$getTransceivers3","_this$getTransceivers4","_getStats","selector","data","peerConnectionGetStats","JSON","parse","senders","receivers","getReceivers","r","matches","sr","getStats","_x5","e","stopped","Boolean","close","peerConnectionClose","_ref","_setStopped","restartIce","peerConnectionRestartIce","_this3","pcId","iceConnectionState","peerConnectionDispose","signalingState","receiverId","values","trackIdx","indexOf","splice","iceGatheringState","channel","dataChannel","_this3$getReceivers$m","_this3$getReceivers$m2","muted","createDataChannel","label","dataChannelDict","channelInfo","_this$getSenders$filt3","_sender$track","_this$getSenders$filt4","transceiverUpdates","_this4","removeStopped","_loop2","update","_this4$getTransceiver","transceiverId","_this4$getTransceiver2","_stopped","isStopped","_sender","_rtpParameters","senderRtpParameters","_receiver","receiverRtpParameters","order","sort","a","b","default"],"sources":["/workspaces/smpm-with-webrtc/node_modules/react-native-webrtc/lib/module/RTCPeerConnection.ts"],"sourcesContent":["\nimport { defineCustomEventTarget } from 'event-target-shim';\nimport { NativeModules } from 'react-native';\n\nimport { addListener, removeListener } from './EventEmitter';\nimport Logger from './Logger';\nimport MediaStream from './MediaStream';\nimport MediaStreamTrack from './MediaStreamTrack';\nimport MediaStreamTrackEvent from './MediaStreamTrackEvent';\nimport RTCDataChannel from './RTCDataChannel';\nimport RTCDataChannelEvent from './RTCDataChannelEvent';\nimport RTCEvent from './RTCEvent';\nimport RTCIceCandidate from './RTCIceCandidate';\nimport RTCIceCandidateEvent from './RTCIceCandidateEvent';\nimport RTCRtpReceiveParameters from './RTCRtpReceiveParameters';\nimport RTCRtpReceiver from './RTCRtpReceiver';\nimport RTCRtpSendParameters from './RTCRtpSendParameters';\nimport RTCRtpSender from './RTCRtpSender';\nimport RTCRtpTransceiver from './RTCRtpTransceiver';\nimport RTCSessionDescription, { RTCSessionDescriptionInit } from './RTCSessionDescription';\nimport RTCTrackEvent from './RTCTrackEvent';\nimport * as RTCUtil from './RTCUtil';\n\nconst log = new Logger('pc');\nconst { WebRTCModule } = NativeModules;\n\ntype RTCSignalingState =\n    | 'stable'\n    | 'have-local-offer'\n    | 'have-remote-offer'\n    | 'have-local-pranswer'\n    | 'have-remote-pranswer'\n    | 'closed';\n\ntype RTCIceGatheringState = 'new' | 'gathering' | 'complete';\n\ntype RTCPeerConnectionState = 'new' | 'connecting' | 'connected' | 'disconnected' | 'failed' | 'closed';\n\ntype RTCIceConnectionState = 'new' | 'checking' | 'connected' | 'completed' | 'failed' | 'disconnected' | 'closed';\n\ntype RTCDataChannelInit = {\n    ordered?: boolean,\n    maxPacketLifeTime?: number,\n    maxRetransmits?: number,\n    protocol?: string,\n    negotiated?: boolean,\n    id?: number\n};\n\nconst PEER_CONNECTION_EVENTS = [\n    'connectionstatechange',\n    'icecandidate',\n    'icecandidateerror',\n    'iceconnectionstatechange',\n    'icegatheringstatechange',\n    'negotiationneeded',\n    'signalingstatechange',\n    'datachannel',\n    'track',\n    'error'\n];\n\nlet nextPeerConnectionId = 0;\n\nexport default class RTCPeerConnection extends defineCustomEventTarget(...PEER_CONNECTION_EVENTS) {\n    localDescription: RTCSessionDescription | null = null;\n    remoteDescription: RTCSessionDescription | null = null;\n\n    signalingState: RTCSignalingState = 'stable';\n    iceGatheringState: RTCIceGatheringState = 'new';\n    connectionState: RTCPeerConnectionState = 'new';\n    iceConnectionState: RTCIceConnectionState = 'new';\n\n    _pcId: number;\n    _transceivers: { order: number, transceiver: RTCRtpTransceiver }[];\n    _remoteStreams: Map<string, MediaStream>;\n    _pendingTrackEvents: any[];\n\n    constructor(configuration) {\n        super();\n\n        this._pcId = nextPeerConnectionId++;\n        WebRTCModule.peerConnectionInit(configuration, this._pcId);\n\n        this._transceivers = [];\n        this._remoteStreams = new Map();\n        this._pendingTrackEvents = [];\n\n        this._registerEvents();\n\n        log.debug(`${this._pcId} ctor`);\n    }\n\n    async createOffer(options) {\n        log.debug(`${this._pcId} createOffer`);\n\n        const {\n            sdpInfo,\n            transceiversInfo\n        } = await WebRTCModule.peerConnectionCreateOffer(this._pcId, RTCUtil.normalizeOfferOptions(options));\n\n        log.debug(`${this._pcId} createOffer OK`);\n\n        this._updateTransceivers(transceiversInfo);\n\n        return sdpInfo;\n    }\n\n    async createAnswer() {\n        log.debug(`${this._pcId} createAnswer`);\n\n        const {\n            sdpInfo,\n            transceiversInfo\n        } = await WebRTCModule.peerConnectionCreateAnswer(this._pcId, {});\n\n        this._updateTransceivers(transceiversInfo);\n\n        return sdpInfo;\n    }\n\n    setConfiguration(configuration): void {\n        WebRTCModule.peerConnectionSetConfiguration(configuration, this._pcId);\n    }\n\n    async setLocalDescription(sessionDescription?: RTCSessionDescription | RTCSessionDescriptionInit): Promise<void> {\n        log.debug(`${this._pcId} setLocalDescription`);\n\n        let desc;\n\n        if (sessionDescription) {\n            desc = {\n                type: sessionDescription.type,\n                sdp: sessionDescription.sdp ?? ''\n            };\n\n            if (!RTCUtil.isSdpTypeValid(desc.type)) {\n                throw new Error(`Invalid session description: invalid type: ${desc.type}`);\n            }\n        } else {\n            desc = null;\n        }\n\n        const {\n            sdpInfo,\n            transceiversInfo\n        } = await WebRTCModule.peerConnectionSetLocalDescription(this._pcId, desc);\n\n        if (sdpInfo.type && sdpInfo.sdp) {\n            this.localDescription = new RTCSessionDescription(sdpInfo);\n        } else {\n            this.localDescription = null;\n        }\n\n        this._updateTransceivers(transceiversInfo, /* removeStopped */ desc?.type === 'answer');\n\n        log.debug(`${this._pcId} setLocalDescription OK`);\n    }\n\n    async setRemoteDescription(sessionDescription: RTCSessionDescription | RTCSessionDescriptionInit): Promise<void> {\n        log.debug(`${this._pcId} setRemoteDescription`);\n\n        if (!sessionDescription) {\n            return Promise.reject(new Error('No session description provided'));\n        }\n\n        const desc = {\n            type: sessionDescription.type,\n            sdp: sessionDescription.sdp ?? ''\n        };\n\n        if (!RTCUtil.isSdpTypeValid(desc.type ?? '')) {\n            throw new Error(`Invalid session description: invalid type: ${desc.type}`);\n        }\n\n        const {\n            sdpInfo,\n            newTransceivers,\n            transceiversInfo\n        } = await WebRTCModule.peerConnectionSetRemoteDescription(this._pcId, desc);\n\n        if (sdpInfo.type && sdpInfo.sdp) {\n            this.remoteDescription = new RTCSessionDescription(sdpInfo);\n        } else {\n            this.remoteDescription = null;\n        }\n\n        newTransceivers?.forEach(t => {\n            const { transceiverOrder, transceiver } = t;\n            const newSender = new RTCRtpSender({ ...transceiver.sender, track: null });\n            const remoteTrack\n                = transceiver.receiver.track ? new MediaStreamTrack(transceiver.receiver.track) : null;\n            const newReceiver = new RTCRtpReceiver({ ...transceiver.receiver, track: remoteTrack });\n            const newTransceiver = new RTCRtpTransceiver({\n                ...transceiver,\n                sender: newSender,\n                receiver: newReceiver,\n            });\n\n            this._insertTransceiverSorted(transceiverOrder, newTransceiver);\n        });\n\n        this._updateTransceivers(transceiversInfo, /* removeStopped */ desc.type === 'answer');\n\n        // Fire track events. They must fire before sRD resolves.\n        const pendingTrackEvents = this._pendingTrackEvents;\n\n        this._pendingTrackEvents = [];\n\n        for (const ev of pendingTrackEvents) {\n            const [ transceiver ] = this\n                .getTransceivers()\n                .filter(t => t.receiver.id ===  ev.receiver.id);\n\n            // We need to fire this event for an existing track sometimes, like\n            // when the transceiver direction (on the sending side) switches from\n            // sendrecv to recvonly and then back.\n\n            // @ts-ignore\n            const track: MediaStreamTrack = transceiver.receiver.track;\n\n            transceiver._mid = ev.transceiver.mid;\n            transceiver._currentDirection = ev.transceiver.currentDirection;\n            transceiver._direction = ev.transceiver.direction;\n\n            // Get the stream object from the event. Create if necessary.\n            const streams: MediaStream[] = ev.streams.map(streamInfo => {\n                // Here we are making sure that we don't create stream objects that already exist\n                // So that event listeners do get the same object if it has been created before.\n                if (!this._remoteStreams.has(streamInfo.streamId)) {\n                    const stream = new MediaStream({\n                        streamId: streamInfo.streamId,\n                        streamReactTag: streamInfo.streamReactTag,\n                        tracks: []\n                    });\n\n                    this._remoteStreams.set(streamInfo.streamId, stream);\n                }\n\n                const stream = this._remoteStreams.get(streamInfo.streamId);\n\n                if (!stream?._tracks.includes(track)) {\n                    stream?._tracks.push(track);\n                }\n\n                return stream;\n            });\n\n            const eventData = {\n                streams,\n                transceiver,\n                track,\n                receiver: transceiver.receiver\n            };\n\n            // @ts-ignore\n            this.dispatchEvent(new RTCTrackEvent('track', eventData));\n\n            streams.forEach(stream => {\n                // @ts-ignore\n                stream.dispatchEvent(new MediaStreamTrackEvent('addtrack', { track }));\n            });\n\n            // Dispatch an unmute event for the track.\n            track._setMutedInternal(false);\n        }\n\n        log.debug(`${this._pcId} setRemoteDescription OK`);\n    }\n\n    async addIceCandidate(candidate): Promise<void> {\n        log.debug(`${this._pcId} addIceCandidate`);\n\n        if (!candidate || !candidate.candidate) {\n            // XXX end-of candidates is not implemented: https://bugs.chromium.org/p/webrtc/issues/detail?id=9218\n            return;\n        }\n\n        if (\n            candidate.sdpMLineIndex === null ||\n            candidate.sdpMLineIndex === undefined ||\n            candidate.sdpMid === null ||\n            candidate.sdpMid === undefined\n        ) {\n            throw new TypeError('`sdpMLineIndex` and `sdpMid` must not null or undefined');\n        }\n\n        const newSdp = await WebRTCModule.peerConnectionAddICECandidate(\n            this._pcId,\n            candidate.toJSON ? candidate.toJSON() : candidate\n        );\n\n        this.remoteDescription = new RTCSessionDescription(newSdp);\n    }\n\n    /**\n     * @brief Adds a new track to the {@link RTCPeerConnection},\n     * and indicates that it is contained in the specified {@link MediaStream}s.\n     * This method has to be synchronous as the W3C API expects a track to be returned\n     * @param {MediaStreamTrack} track The track to be added\n     * @param {...MediaStream} streams One or more {@link MediaStream}s the track needs to be added to\n     * https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-addtrack\n     */\n    addTrack(track: MediaStreamTrack, ...streams: MediaStream[]): RTCRtpSender {\n        log.debug(`${this._pcId} addTrack`);\n\n        if (this.connectionState === 'closed') {\n            throw new Error('Peer Connection is closed');\n        }\n\n        if (this._trackExists(track)) {\n            throw new Error('Track already exists in a sender');\n        }\n\n        const streamIds = streams.map(s => s.id);\n        const result = WebRTCModule.peerConnectionAddTrack(this._pcId, track.id, { streamIds });\n\n        if (result === null) {\n            throw new Error('Could not add sender');\n        }\n\n        const { transceiverOrder, transceiver, sender } = result;\n\n        // According to the W3C docs, the sender could have been reused, and\n        // so we check if that is the case, and update accordingly.\n        const [ existingSender ] = this\n            .getSenders()\n            .filter(s => s.id === sender.id);\n\n        if (existingSender) {\n            // Update sender\n            existingSender._track = track;\n\n            // Update the corresponding transceiver as well\n            const [ existingTransceiver ] = this\n                .getTransceivers()\n                .filter(t => t.sender.id === existingSender.id);\n\n            existingTransceiver._direction = transceiver.direction;\n            existingTransceiver._currentDirection = transceiver.currentDirection;\n\n            return existingSender;\n        }\n\n        // This is a new transceiver, should create a transceiver for it and add it\n        const newSender = new RTCRtpSender({ ...transceiver.sender, track });\n        const remoteTrack = transceiver.receiver.track ? new MediaStreamTrack(transceiver.receiver.track) : null;\n        const newReceiver = new RTCRtpReceiver({ ...transceiver.receiver, track: remoteTrack });\n        const newTransceiver = new RTCRtpTransceiver({\n            ...transceiver,\n            sender: newSender,\n            receiver: newReceiver,\n        });\n\n        this._insertTransceiverSorted(transceiverOrder, newTransceiver);\n\n        return newSender;\n    }\n\n    addTransceiver(source: 'audio' | 'video' | MediaStreamTrack, init): RTCRtpTransceiver {\n        log.debug(`${this._pcId} addTransceiver`);\n\n        let src = {};\n\n        if (source === 'audio') {\n            src = { type: 'audio' };\n        } else if (source === 'video') {\n            src = { type: 'video' };\n        } else {\n            src = { trackId: source.id };\n        }\n\n        // Extract the stream ids\n        if (init && init.streams) {\n            init.streamIds = init.streams.map(stream => stream.id);\n        }\n\n        const result = WebRTCModule.peerConnectionAddTransceiver(this._pcId, { ...src, init: { ...init } });\n\n        if (result === null) {\n            throw new Error('Transceiver could not be added');\n        }\n\n        const t = result.transceiver;\n        let track: MediaStreamTrack | null = null;\n\n        if (typeof source === 'string') {\n            if (t.sender.track) {\n                track = new MediaStreamTrack(t.sender.track);\n            }\n        } else {\n            // 'source' is a MediaStreamTrack\n            track = source;\n        }\n\n        const sender = new RTCRtpSender({ ...t.sender, track });\n        const remoteTrack = t.receiver.track ? new MediaStreamTrack(t.receiver.track) : null;\n        const receiver = new RTCRtpReceiver({ ...t.receiver, track: remoteTrack });\n        const transceiver = new RTCRtpTransceiver({\n            ...result.transceiver,\n            sender,\n            receiver\n        });\n\n        this._insertTransceiverSorted(result.transceiverOrder, transceiver);\n\n        return transceiver;\n    }\n\n    removeTrack(sender: RTCRtpSender) {\n        log.debug(`${this._pcId} removeTrack`);\n\n        if (this._pcId !== sender._peerConnectionId) {\n            throw new Error('Sender does not belong to this peer connection');\n        }\n\n        if (this.connectionState === 'closed') {\n            throw new Error('Peer Connection is closed');\n        }\n\n        const existingSender = this\n            .getSenders()\n            .find(s => s === sender);\n\n        if (!existingSender) {\n            throw new Error('Sender does not exist');\n        }\n\n        if (existingSender.track === null) {\n            return;\n        }\n\n        // Blocking!\n        WebRTCModule.peerConnectionRemoveTrack(this._pcId, sender.id);\n\n        existingSender._track = null;\n\n        const [ existingTransceiver ] = this\n            .getTransceivers()\n            .filter(t => t.sender.id === existingSender.id);\n\n        existingTransceiver._direction = existingTransceiver.direction === 'sendrecv' ? 'recvonly' : 'inactive';\n    }\n\n    async getStats(selector?: MediaStreamTrack) {\n        log.debug(`${this._pcId} getStats`);\n\n        if (!selector) {\n            const data = await WebRTCModule.peerConnectionGetStats(this._pcId);\n\n            /**\n             * On both Android and iOS it is faster to construct a single\n             * JSON string representing the Map of StatsReports and have it\n             * pass through the React Native bridge rather than the Map of\n             * StatsReports. While the implementations do try to be faster in\n             * general, the stress is on being faster to pass through the React\n             * Native bridge which is a bottleneck that tends to be visible in\n             * the UI when there is congestion involving UI-related passing.\n             */\n            return new Map(JSON.parse(data));\n        } else {\n            const senders = this.getSenders().filter(s => s.track === selector);\n            const receivers = this.getReceivers().filter(r => r.track === selector);\n            const matches = senders.length + receivers.length;\n\n            if (matches === 0) {\n                throw new Error('Invalid selector: could not find matching sender / receiver');\n            } else if (matches > 1) {\n                throw new Error('Invalid selector: multiple matching senders / receivers');\n            } else {\n                const sr = senders[0] || receivers[0];\n\n                return sr.getStats();\n            }\n        }\n    }\n\n    getTransceivers(): RTCRtpTransceiver[] {\n        return this._transceivers.map(e => e.transceiver);\n    }\n\n    getSenders(): RTCRtpSender[] {\n        // @ts-ignore\n        return this._transceivers.map(e => !e.transceiver.stopped && e.transceiver.sender).filter(Boolean);\n    }\n\n    getReceivers(): RTCRtpReceiver[] {\n        // @ts-ignore\n        return this._transceivers.map(e => !e.transceiver.stopped && e.transceiver.receiver).filter(Boolean);\n    }\n\n    close(): void {\n        log.debug(`${this._pcId} close`);\n\n        if (this.connectionState === 'closed') {\n            return;\n        }\n\n        WebRTCModule.peerConnectionClose(this._pcId);\n\n        // Mark transceivers as stopped.\n        this._transceivers.forEach(({ transceiver })=> {\n            transceiver._setStopped();\n        });\n    }\n\n    restartIce(): void {\n        WebRTCModule.peerConnectionRestartIce(this._pcId);\n    }\n\n    _registerEvents(): void {\n        addListener(this, 'peerConnectionOnRenegotiationNeeded', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            // @ts-ignore\n            this.dispatchEvent(new RTCEvent('negotiationneeded'));\n        });\n\n        addListener(this, 'peerConnectionIceConnectionChanged', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            this.iceConnectionState = ev.iceConnectionState;\n\n            // @ts-ignore\n            this.dispatchEvent(new RTCEvent('iceconnectionstatechange'));\n        });\n\n        addListener(this, 'peerConnectionStateChanged', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            this.connectionState = ev.connectionState;\n\n            // @ts-ignore\n            this.dispatchEvent(new RTCEvent('connectionstatechange'));\n\n            if (ev.connectionState === 'closed') {\n                // This PeerConnection is done, clean up.\n                removeListener(this);\n\n                WebRTCModule.peerConnectionDispose(this._pcId);\n            }\n        });\n\n        addListener(this, 'peerConnectionSignalingStateChanged', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            this.signalingState = ev.signalingState;\n            // @ts-ignore\n            this.dispatchEvent(new RTCEvent('signalingstatechange'));\n        });\n\n        // Consider moving away from this event: https://github.com/WebKit/WebKit/pull/3953\n        addListener(this, 'peerConnectionOnTrack', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            log.debug(`${this._pcId} ontrack`);\n\n            // NOTE: We need to make sure the track event fires right before sRD completes,\n            // so we queue them up here and dispatch the events when sRD fires, but before completing it.\n            // In the future we should probably implement out own logic and drop this event altogether.\n            this._pendingTrackEvents.push(ev);\n        });\n\n        addListener(this, 'peerConnectionOnRemoveTrack', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            log.debug(`${this._pcId} onremovetrack ${ev.receiverId}`);\n\n            const receiver = this.getReceivers().find(r => r.id === ev.receiverId);\n            const track = receiver?.track;\n\n            if (receiver && track) {\n                // As per the spec:\n                // - Remove the track from any media streams that were previously passed to the `track` event.\n                // https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-removetrack,\n                // - Mark the track as muted:\n                // https://w3c.github.io/webrtc-pc/#process-remote-track-removal\n                for (const stream of this._remoteStreams.values()) {\n                    if (stream._tracks.includes(track)) {\n                        const trackIdx = stream._tracks.indexOf(track);\n\n                        log.debug(`${this._pcId} removetrack ${track.id}`);\n\n                        stream._tracks.splice(trackIdx, 1);\n\n                        // @ts-ignore\n                        stream.dispatchEvent(new MediaStreamTrackEvent('removetrack', { track }));\n\n                        // Dispatch a mute event for the track.\n                        track._setMutedInternal(true);\n                    }\n                }\n            }\n        });\n\n        addListener(this, 'peerConnectionGotICECandidate', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            const sdpInfo = ev.sdp;\n\n            // Can happen when doing a rollback.\n            if (sdpInfo.type && sdpInfo.sdp) {\n                this.localDescription = new RTCSessionDescription(sdpInfo);\n            } else {\n                this.localDescription = null;\n            }\n\n            const candidate = new RTCIceCandidate(ev.candidate);\n\n            // @ts-ignore\n            this.dispatchEvent(new RTCIceCandidateEvent('icecandidate', { candidate }));\n        });\n\n        addListener(this, 'peerConnectionIceGatheringChanged', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            this.iceGatheringState = ev.iceGatheringState;\n\n            if (this.iceGatheringState === 'complete') {\n                const sdpInfo = ev.sdp;\n\n                // Can happen when doing a rollback.\n                if (sdpInfo.type && sdpInfo.sdp) {\n                    this.localDescription = new RTCSessionDescription(sdpInfo);\n                } else {\n                    this.localDescription = null;\n                }\n\n                // @ts-ignore\n                this.dispatchEvent(new RTCIceCandidateEvent('icecandidate', { candidate: null }));\n            }\n\n            // @ts-ignore\n            this.dispatchEvent(new RTCEvent('icegatheringstatechange'));\n        });\n\n        addListener(this, 'peerConnectionDidOpenDataChannel', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            const channel = new RTCDataChannel(ev.dataChannel);\n\n            // @ts-ignore\n            this.dispatchEvent(new RTCDataChannelEvent('datachannel', { channel }));\n        });\n\n        addListener(this, 'mediaStreamTrackMuteChanged', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            const [\n                track\n            ] = this.getReceivers().map(r => r.track).filter(t => t?.id === ev.trackId);\n\n            if (track) {\n                track._setMutedInternal(ev.muted);\n            }\n        });\n    }\n\n    /**\n     * Creates a new RTCDataChannel object with the given label. The\n     * RTCDataChannelInit dictionary can be used to configure properties of the\n     * underlying channel such as data reliability.\n     *\n     * @param {string} label - the value with which the label attribute of the new\n     * instance is to be initialized\n     * @param {RTCDataChannelInit} dataChannelDict - an optional dictionary of\n     * values with which to initialize corresponding attributes of the new\n     * instance such as id\n     */\n    createDataChannel(label: string, dataChannelDict?: RTCDataChannelInit): RTCDataChannel {\n        if (dataChannelDict && 'id' in dataChannelDict) {\n            const id = dataChannelDict.id;\n\n            if (typeof id !== 'number') {\n                throw new TypeError('DataChannel id must be a number: ' + id);\n            }\n        }\n\n        const channelInfo = WebRTCModule.createDataChannel(this._pcId, label, dataChannelDict);\n\n        if (channelInfo === null) {\n            throw new TypeError('Failed to create new DataChannel');\n        }\n\n        return new RTCDataChannel(channelInfo);\n    }\n\n    /**\n     * Check whether a media stream track exists already in a sender.\n     * See https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-addtrack for more information\n     */\n    _trackExists(track: MediaStreamTrack): boolean {\n        const [ sender ] = this\n            .getSenders()\n            .filter(\n                sender => sender.track?.id === track.id\n            );\n\n        return sender? true : false;\n    }\n\n    /**\n     * Updates transceivers after offer/answer updates if necessary.\n     */\n    _updateTransceivers(transceiverUpdates, removeStopped = false) {\n        for (const update of transceiverUpdates) {\n            const [ transceiver ] = this\n                .getTransceivers()\n                .filter(t => t.sender.id === update.transceiverId);\n\n            if (!transceiver) {\n                continue;\n            }\n\n            transceiver._currentDirection = update.currentDirection;\n            transceiver._mid = update.mid;\n            transceiver._stopped = Boolean(update.isStopped);\n            transceiver._sender._rtpParameters = new RTCRtpSendParameters(update.senderRtpParameters);\n            transceiver._receiver._rtpParameters = new RTCRtpReceiveParameters(update.receiverRtpParameters);\n        }\n\n        if (removeStopped) {\n            const stopped = this.getTransceivers().filter(t => t.stopped);\n            const newTransceivers = this._transceivers.filter(t => !stopped.includes(t.transceiver));\n\n            this._transceivers = newTransceivers;\n        }\n    }\n\n    /**\n     * Inserts transceiver into the transceiver array in the order they are created (timestamp).\n     * @param order an index that refers to when it it was created relatively.\n     * @param transceiver the transceiver object to be inserted.\n     */\n    _insertTransceiverSorted(order: number, transceiver: RTCRtpTransceiver) {\n        this._transceivers.push({ order, transceiver });\n        this._transceivers.sort((a, b) => a.order - b.order);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}